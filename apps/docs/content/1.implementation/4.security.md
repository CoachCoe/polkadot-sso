---
title: Security
description: Security features and best practices for Polkadot SSO
---

# Security

Polkadot SSO implements enterprise-grade security measures using Better Auth's secure architecture and Polkadot's cryptographic primitives.

## Security Architecture

### 1. Better Auth Integration

The plugin leverages Better Auth's battle-tested security features:

- **Stateless Authentication**: JWT-based sessions without server-side storage
- **Plugin Architecture**: Isolated authentication logic
- **Request Validation**: Built-in input sanitization and validation
- **Audit Logging**: Comprehensive security event tracking

### 2. Cryptographic Security

#### Signature Verification

All signatures are cryptographically verified using Polkadot's signature verification:

```typescript
import { signatureVerify } from "@polkadot/util-crypto"

const result = signatureVerify(messageBytes, signatureBytes, address)
return result.isValid
```

#### Challenge-Response Authentication

- **Unique Challenges**: Each challenge includes timestamp and nonce
- **Expiration**: Challenges expire after 5 minutes
- **Replay Protection**: One-time use challenges prevent replay attacks
- **Address Binding**: Challenges are bound to specific addresses

#### PKCE (Proof Key for Code Exchange)

- **Code Verifier**: Random 32-byte string
- **Code Challenge**: SHA256 hash of the verifier
- **S256 Method**: Uses SHA256 for challenge generation
- **State Parameter**: Prevents CSRF attacks

### 3. Session Security

#### JWT Token Management

```typescript
// Token structure
{
  sub: "user-id",
  address: "polkadot-address",
  chain: "polkadot",
  iat: 1640995200,
  exp: 1640996100
}
```

#### Token Security Features

- **Short Expiration**: 15-minute access token lifetime
- **Secure Secrets**: 32+ character cryptographically strong secrets
- **Algorithm**: HMAC-SHA256 for token signing
- **Claims**: Minimal required claims only

#### Session Management

- **Stateless**: No server-side session storage
- **Automatic Refresh**: Seamless token renewal
- **Secure Logout**: Token invalidation on sign out
- **Cross-Origin**: Secure cross-origin session handling

## Security Features

### 1. Input Validation

All inputs are validated and sanitized:

```typescript
// Address validation
const isValid = isValidAddress(address, ss58Format)

// Message sanitization
const sanitizedMessage = sanitizeInput(message)

// Parameter validation
const validatedParams = validateParameters(params)
```

### 2. Rate Limiting

Built-in protection against abuse:

- **Challenge Generation**: 10 requests per minute per IP
- **Signature Verification**: 5 attempts per minute per IP
- **Session Creation**: 3 sessions per minute per IP
- **Error Handling**: Exponential backoff on failures

### 3. Audit Logging

Comprehensive security event tracking:

```typescript
// Audit log entry
{
  timestamp: "2024-01-01T00:00:00Z",
  event: "polkadot_auth_request",
  ip: "192.168.1.1",
  userAgent: "Mozilla/5.0...",
  success: true,
  details: {
    address: "1A2B3C...",
    chain: "polkadot",
    challengeId: "uuid"
  }
}
```

### 4. Error Handling

Secure error handling prevents information leakage:

- **Generic Messages**: No sensitive information in error responses
- **Logging**: Detailed errors logged server-side only
- **Rate Limiting**: Automatic protection against error-based attacks
- **Graceful Degradation**: Fallback mechanisms for failures

## Best Practices

### 1. Environment Security

#### Required Environment Variables

```bash
# Strong session secret (32+ characters)
SESSION_SECRET=your-32-character-session-secret

# Secure database URL
DATABASE_URL=file:./data/auth.db

# Production RPC URLs
POLKADOT_RPC_URL=wss://rpc.polkadot.io
KUSAMA_RPC_URL=wss://kusama-rpc.polkadot.io
```

#### Security Checklist

- ✅ Use strong, unique session secrets
- ✅ Enable HTTPS in production
- ✅ Use secure database connections
- ✅ Implement proper CORS policies
- ✅ Regular security updates

### 2. Client Security

#### Wallet Integration

```typescript
// Secure wallet connection
const extensions = await web3Enable('Your App Name')

// Validate wallet responses
if (!extensions.length) {
  throw new Error('No wallet extensions found')
}

// Secure message signing
const signature = await injector.signer.signRaw({
  address: selectedAccount.address,
  data: challenge.message,
  type: 'bytes'
})
```

#### Frontend Security

- **HTTPS Only**: Always use HTTPS in production
- **Content Security Policy**: Implement CSP headers
- **Input Validation**: Validate all user inputs
- **Error Handling**: Don't expose sensitive information

### 3. Server Security

#### Better Auth Configuration

```typescript
const auth = betterAuth({
  secret: process.env.SESSION_SECRET,
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 days
    updateAge: 60 * 60 * 24      // 1 day
  },
  jwt: {
    expiresIn: 60 * 15           // 15 minutes
  }
})
```

#### Production Security

- **Environment Variables**: Never commit secrets to code
- **Database Security**: Use encrypted database connections
- **Network Security**: Implement proper firewall rules
- **Monitoring**: Set up security monitoring and alerting

## Threat Mitigation

### 1. Replay Attacks

**Threat**: Attacker replays a valid signature
**Mitigation**: 
- One-time use challenges
- Timestamp validation
- Nonce uniqueness

### 2. Man-in-the-Middle

**Threat**: Attacker intercepts authentication flow
**Mitigation**:
- HTTPS enforcement
- Certificate pinning
- PKCE implementation

### 3. Session Hijacking

**Threat**: Attacker steals session tokens
**Mitigation**:
- Short token expiration
- Secure token storage
- Automatic token refresh

### 4. Brute Force

**Threat**: Attacker attempts multiple authentication attempts
**Mitigation**:
- Rate limiting
- Challenge expiration
- Account lockout mechanisms

## Compliance

### 1. Data Protection

- **Minimal Data**: Only collect necessary user information
- **Encryption**: All sensitive data encrypted at rest
- **Retention**: Configurable data retention policies
- **Deletion**: Secure data deletion on user request

### 2. Privacy

- **No Tracking**: No user behavior tracking
- **Local Storage**: Minimal client-side data storage
- **Transparency**: Clear privacy policy
- **User Control**: User control over their data

### 3. Audit Trail

- **Comprehensive Logging**: All security events logged
- **Retention**: Configurable log retention
- **Monitoring**: Real-time security monitoring
- **Reporting**: Security incident reporting

## Security Testing

### 1. Unit Tests

Comprehensive test coverage for security functions:

```typescript
describe('Security', () => {
  it('should verify valid signatures', async () => {
    const isValid = await verifySignature(message, signature, address, provider)
    expect(isValid).toBe(true)
  })

  it('should reject invalid signatures', async () => {
    const isValid = await verifySignature(message, 'invalid', address, provider)
    expect(isValid).toBe(false)
  })
})
```

### 2. Integration Tests

End-to-end security testing:

- Authentication flow testing
- Error handling validation
- Rate limiting verification
- Session management testing

### 3. Security Audits

Regular security assessments:

- Code review for security vulnerabilities
- Penetration testing
- Dependency vulnerability scanning
- Security best practice compliance
