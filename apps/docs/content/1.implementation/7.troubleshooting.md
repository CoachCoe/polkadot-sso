---
title: Troubleshooting
description: Common issues and solutions for Polkadot SSO
---

# Troubleshooting Guide

This guide helps you diagnose and resolve common issues with Polkadot SSO.

## Common Issues

### Wallet Connection Issues

#### Problem: "No wallet extension found"

**Symptoms:**
- Error message: "No wallet extension found. Please install Polkadot.js"
- `web3Enable` returns empty array

**Solutions:**

1. **Install Polkadot.js Extension:**
```javascript
// Check if extension is installed
const extensions = await web3Enable('My App');
if (extensions.length === 0) {
  // Direct user to install
  window.open('https://polkadot.js.org/extension/', '_blank');
}
```

2. **Check Browser Compatibility:**
- Polkadot.js works on Chrome, Firefox, Edge
- Not supported on Safari mobile

3. **Enable Extension for Site:**
```javascript
// Ensure proper app name
const extensions = await web3Enable('Your App Name');

// Check extension permissions
if (!extensions || extensions.length === 0) {
  console.error('User needs to authorize the extension');
}
```

#### Problem: "No accounts found"

**Solutions:**

1. **Check Account Creation:**
```javascript
const accounts = await web3Accounts();
if (accounts.length === 0) {
  alert('Please create an account in your wallet');
}
```

2. **Request Account Access:**
```javascript
// Some wallets require explicit permission
const accounts = await web3Accounts({
  ss58Format: 42, // Substrate generic format
  accountType: ['sr25519', 'ed25519']
});
```

### Authentication Issues

#### Problem: Challenge extraction fails

**Error:** "Failed to extract challenge data from HTML response"

**Solution:**

```javascript
// Improved challenge extraction
async function extractChallengeData(html: string) {
  // Method 1: Extract from window.CHALLENGE_DATA
  const scriptMatch = html.match(/window\.CHALLENGE_DATA\s*=\s*({[^}]+})/s);

  if (scriptMatch) {
    try {
      const dataStr = scriptMatch[1]
        .replace(/(\w+):/g, '"$1":')  // Add quotes to keys
        .replace(/'/g, '"');           // Replace single quotes

      return JSON.parse(dataStr);
    } catch (e) {
      console.error('Failed to parse challenge data:', e);
    }
  }

  // Method 2: Extract individual fields
  const challengeId = html.match(/challengeId:\s*["']([^"']+)["']/)?.[1];
  const message = html.match(/message:\s*["']([^"']+)["']/)?.[1];
  const codeVerifier = html.match(/codeVerifier:\s*["']([^"']+)["']/)?.[1];
  const state = html.match(/state:\s*["']([^"']+)["']/)?.[1];

  if (challengeId && message) {
    return {
      challengeId,
      message: message.replace(/\\n/g, '\n'),
      codeVerifier,
      state
    };
  }

  throw new Error('Could not extract challenge data');
}
```

#### Problem: Signature verification fails

**Error:** "Signature verification failed"

**Common Causes and Solutions:**

1. **Wrong Message Format:**
```javascript
// Ensure message matches exactly what was signed
const message = challenge.message; // Don't modify!

// Common mistake: adding extra whitespace
const wrongMessage = challenge.message.trim(); // DON'T DO THIS
```

2. **Encoding Issues:**
```javascript
// Correct signature format
const signRaw = injector?.signer?.signRaw;
const { signature } = await signRaw({
  address: address,
  data: message, // Raw string, not encoded
  type: 'bytes'
});

// Ensure signature is hex format
if (!signature.startsWith('0x')) {
  signature = '0x' + signature;
}
```

3. **Address Format Mismatch:**
```javascript
// Ensure consistent address format
import { encodeAddress } from '@polkadot/util-crypto';

// Convert to correct SS58 format
const formattedAddress = encodeAddress(address, 42);
```

#### Problem: "Challenge expired"

**Solutions:**

1. **Increase Challenge TTL (Server):**
```javascript
// In challengeService.ts
const CHALLENGE_TTL = 5 * 60 * 1000; // Increase from 5 to 10 minutes
```

2. **Retry Logic (Client):**
```javascript
async function signInWithRetry(address: string, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const challenge = await authService.createChallenge(address);
      const signature = await requestSignature(challenge);
      return await authService.verifySignature(signature, challenge.id, address);
    } catch (error) {
      if (error.message === 'Challenge expired' && i < maxRetries - 1) {
        console.log('Challenge expired, retrying...');
        continue;
      }
      throw error;
    }
  }
}
```

### Token Issues

#### Problem: "Invalid or expired token"

**Solutions:**

1. **Implement Token Refresh:**
```javascript
class AuthService {
  async makeAuthenticatedRequest(url: string, options = {}) {
    try {
      return await this.request(url, options);
    } catch (error) {
      if (error.status === 401 && this.refreshToken) {
        // Try refreshing the token
        await this.refreshAccessToken();
        // Retry the request
        return await this.request(url, options);
      }
      throw error;
    }
  }

  async refreshAccessToken() {
    const response = await fetch('/api/auth/token', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'refresh_token',
        refresh_token: this.refreshToken,
        client_id: CLIENT_ID,
        client_secret: CLIENT_SECRET
      })
    });

    if (!response.ok) {
      // Refresh failed, need to re-authenticate
      this.clearTokens();
      window.location.href = '/login';
      return;
    }

    const { access_token, refresh_token } = await response.json();
    this.saveTokens(access_token, refresh_token);
  }
}
```

2. **Check Token Expiration:**
```javascript
function isTokenExpired(token: string): boolean {
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    const exp = payload.exp * 1000; // Convert to milliseconds
    return Date.now() > exp;
  } catch {
    return true;
  }
}
```

#### Problem: Token not persisting across page refresh

**Solutions:**

1. **Proper Storage Implementation:**
```javascript
class TokenStorage {
  // Use localStorage for development
  saveTokens(accessToken: string, refreshToken: string) {
    localStorage.setItem('access_token', accessToken);
    localStorage.setItem('refresh_token', refreshToken);
  }

  // For production, use httpOnly cookies
  saveTokensSecure(accessToken: string, refreshToken: string) {
    // Server should set httpOnly cookies
    fetch('/api/auth/set-cookies', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ accessToken, refreshToken })
    });
  }

  loadTokens() {
    return {
      accessToken: localStorage.getItem('access_token'),
      refreshToken: localStorage.getItem('refresh_token')
    };
  }
}
```

### CORS Issues

#### Problem: "CORS policy blocked request"

**Solutions:**

1. **Server-Side CORS Configuration:**
```javascript
// In apps/sso/src/config/cors.ts
const corsOptions = {
  origin: function (origin, callback) {
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];

    // Allow requests with no origin (mobile apps, Postman)
    if (!origin) return callback(null, true);

    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true, // Important for cookies/auth
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400 // Cache preflight for 24 hours
};

app.use(cors(corsOptions));
```

2. **Client-Side Request Configuration:**
```javascript
// Always include credentials for auth requests
fetch('http://localhost:3001/api/auth/session', {
  method: 'GET',
  credentials: 'include', // Important!
  headers: {
    'Authorization': `Bearer ${accessToken}`
  }
});
```

### Rate Limiting Issues

#### Problem: "Too many requests"

**Solutions:**

1. **Implement Exponential Backoff:**
```javascript
async function requestWithBackoff(
  fn: () => Promise<any>,
  maxRetries = 3
) {
  let lastError;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      if (error.status === 429) {
        // Rate limited - wait exponentially
        const delay = Math.min(1000 * Math.pow(2, i), 10000);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      throw error;
    }
  }

  throw lastError;
}
```

2. **Cache Responses:**
```javascript
class CachedAuthService {
  private cache = new Map();

  async getSession() {
    const cacheKey = 'session';
    const cached = this.cache.get(cacheKey);

    if (cached && cached.expires > Date.now()) {
      return cached.data;
    }

    const session = await this.fetchSession();

    this.cache.set(cacheKey, {
      data: session,
      expires: Date.now() + 60000 // Cache for 1 minute
    });

    return session;
  }
}
```

### Database Issues

#### Problem: "Database is locked"

**Solutions:**

1. **Enable WAL Mode (SQLite):**
```javascript
// In database initialization
db.run('PRAGMA journal_mode=WAL');
db.run('PRAGMA busy_timeout=5000'); // Wait up to 5 seconds
```

2. **Connection Pooling:**
```javascript
class DatabasePool {
  private connections: Database[] = [];
  private maxConnections = 10;

  async getConnection(): Promise<Database> {
    if (this.connections.length < this.maxConnections) {
      const db = await this.createConnection();
      this.connections.push(db);
      return db;
    }

    // Wait for available connection
    return new Promise((resolve) => {
      const checkInterval = setInterval(() => {
        const available = this.connections.find(db => !db.inUse);
        if (available) {
          clearInterval(checkInterval);
          available.inUse = true;
          resolve(available);
        }
      }, 100);
    });
  }
}
```

## Debugging Tools

### Enable Debug Logging

```javascript
// Client-side
localStorage.setItem('DEBUG', 'auth:*');

// Server-side
DEBUG=sso:* npm run dev
```

### Network Inspection

```javascript
// Log all auth requests
const originalFetch = window.fetch;
window.fetch = function(...args) {
  const [url, options] = args;

  if (url.includes('/api/auth')) {
    console.group('Auth Request');
    console.log('URL:', url);
    console.log('Options:', options);
    console.groupEnd();
  }

  return originalFetch.apply(this, args)
    .then(response => {
      if (url.includes('/api/auth')) {
        console.group('Auth Response');
        console.log('Status:', response.status);
        console.log('Headers:', response.headers);
        console.groupEnd();
      }
      return response;
    });
};
```

### Session Debugging

```javascript
// Debug session state
function debugSession() {
  const tokens = {
    access: localStorage.getItem('access_token'),
    refresh: localStorage.getItem('refresh_token')
  };

  console.group('Session Debug');
  console.log('Has Access Token:', !!tokens.access);
  console.log('Has Refresh Token:', !!tokens.refresh);

  if (tokens.access) {
    try {
      const payload = JSON.parse(atob(tokens.access.split('.')[1]));
      console.log('Token Expires:', new Date(payload.exp * 1000));
      console.log('Token Subject:', payload.sub);
      console.log('Token Session ID:', payload.sid);
    } catch (e) {
      console.error('Invalid token format');
    }
  }

  console.groupEnd();
}
```

## Performance Issues

### Slow Authentication

**Solutions:**

1. **Optimize Database Queries:**
```sql
-- Add indexes for common queries
CREATE INDEX idx_challenges_address ON challenges(address);
CREATE INDEX idx_challenges_expires ON challenges(expires_at);
CREATE INDEX idx_sessions_token ON sessions(access_token);
CREATE INDEX idx_sessions_address ON sessions(address);
```

2. **Implement Caching:**
```javascript
// Redis caching for sessions
import Redis from 'ioredis';
const redis = new Redis();

async function getCachedSession(token: string) {
  // Check cache first
  const cached = await redis.get(`session:${token}`);
  if (cached) return JSON.parse(cached);

  // Fetch from database
  const session = await db.getSession(token);

  // Cache for 5 minutes
  await redis.setex(
    `session:${token}`,
    300,
    JSON.stringify(session)
  );

  return session;
}
```

## Getting Help

### Diagnostic Information

When reporting issues, include:

```javascript
// Collect diagnostic info
function collectDiagnostics() {
  return {
    browser: navigator.userAgent,
    timestamp: new Date().toISOString(),
    url: window.location.href,
    wallet: {
      installed: typeof window.injectedWeb3 !== 'undefined',
      extensions: Object.keys(window.injectedWeb3 || {})
    },
    tokens: {
      hasAccess: !!localStorage.getItem('access_token'),
      hasRefresh: !!localStorage.getItem('refresh_token')
    },
    errors: console.error.calls || []
  };
}

// Send diagnostics with bug report
const diagnostics = collectDiagnostics();
console.log('Diagnostics:', diagnostics);
```

### Support Channels

- GitHub Issues: [github.com/polkadot-auth/polkadot-sso/issues](https://github.com/polkadot-auth/polkadot-sso/issues)
- Discord: Polkadot Development Channel
- Documentation: This guide
- Example Code: `/example` directory