---
title: Client Integration
description: How to integrate Polkadot SSO in your application
---

# Client Integration Guide

This guide shows how to integrate Polkadot SSO into various client applications.

## React Integration

### Installation

```bash
npm install @polkadot/extension-dapp @polkadot/api axios
```

### Auth Service Implementation

Create a complete authentication service:

```typescript
// services/authService.ts
import axios from 'axios';

const SSO_SERVER_URL = import.meta.env.VITE_SSO_SERVER_URL || 'http://localhost:3001';
const CLIENT_ID = import.meta.env.VITE_SSO_CLIENT_ID || 'demo-client';
const CLIENT_SECRET = import.meta.env.VITE_SSO_CLIENT_SECRET || 'default-client-secret';
const REDIRECT_URL = import.meta.env.VITE_SSO_REDIRECT_URL || 'http://localhost:5173/callback';

interface Challenge {
  id: string;
  message: string;
  codeVerifier: string;
  state: string;
  expiresAt: string;
}

interface Session {
  user: {
    address: string;
    chain: string;
    wallet: string;
  };
  accessToken: string;
  refreshToken: string;
  expiresAt: string;
}

class AuthService {
  private accessToken: string | null = null;
  private refreshToken: string | null = null;

  constructor() {
    this.loadTokens();
  }

  private loadTokens() {
    this.accessToken = localStorage.getItem('access_token');
    this.refreshToken = localStorage.getItem('refresh_token');
  }

  private saveTokens(accessToken: string, refreshToken: string) {
    this.accessToken = accessToken;
    this.refreshToken = refreshToken;
    localStorage.setItem('access_token', accessToken);
    localStorage.setItem('refresh_token', refreshToken);
  }

  private clearTokens() {
    this.accessToken = null;
    this.refreshToken = null;
    localStorage.removeItem('access_token');
    localStorage.removeItem('refresh_token');
  }

  async createChallenge(address: string, chain: string = 'westend'): Promise<Challenge> {
    const response = await axios.get(`${SSO_SERVER_URL}/api/auth/challenge`, {
      params: { client_id: CLIENT_ID, address, chain }
    });

    // Extract challenge data from HTML response
    const html = response.data;
    const match = html.match(/window\.CHALLENGE_DATA\s*=\s*({[^}]+})/s);
    if (!match) throw new Error('Failed to extract challenge data');

    const dataStr = match[1]
      .replace(/(\w+):/g, '"$1":')
      .replace(/'/g, '"');

    const parsed = JSON.parse(dataStr);
    const challengeData = {
      id: parsed.challengeId,
      message: parsed.message.replace(/\\n/g, '\n'),
      codeVerifier: parsed.codeVerifier,
      state: parsed.state,
      expiresAt: new Date(Date.now() + 5 * 60 * 1000).toISOString()
    };

    // Store for later verification
    sessionStorage.setItem(`challenge_${challengeData.id}`, JSON.stringify(challengeData));

    return challengeData;
  }

  async verifySignature(
    signature: string,
    challengeId: string,
    address: string
  ): Promise<{ success: boolean; tokens?: any }> {
    const stored = sessionStorage.getItem(`challenge_${challengeId}`);
    if (!stored) throw new Error('Challenge not found');

    const challenge = JSON.parse(stored) as Challenge;

    // Build verification URL
    const params = new URLSearchParams({
      signature,
      challenge_id: challengeId,
      address,
      code_verifier: challenge.codeVerifier,
      state: challenge.state,
    });

    try {
      const response = await axios.get(
        `${SSO_SERVER_URL}/api/auth/verify?${params.toString()}`,
        {
          maxRedirects: 0,
          validateStatus: (status) => status >= 200 && status < 400
        }
      );

      // Extract auth code from redirect
      const redirectUrl = response.headers.location;
      if (!redirectUrl) throw new Error('No redirect URL');

      const url = new URL(redirectUrl, SSO_SERVER_URL);
      const code = url.searchParams.get('code');
      const state = url.searchParams.get('state');

      if (code && state === challenge.state) {
        return await this.exchangeCodeForTokens(code);
      }

      throw new Error('Verification failed');
    } catch (error) {
      console.error('Signature verification failed:', error);
      throw error;
    }
  }

  async exchangeCodeForTokens(code: string) {
    const response = await axios.post(`${SSO_SERVER_URL}/api/auth/token`, {
      grant_type: 'authorization_code',
      code,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
      redirect_uri: REDIRECT_URL,
    });

    const { access_token, refresh_token } = response.data;
    this.saveTokens(access_token, refresh_token);

    return { success: true, tokens: response.data };
  }

  async getSession(): Promise<Session | null> {
    if (!this.accessToken) return null;

    try {
      const response = await axios.get(`${SSO_SERVER_URL}/api/auth/session`, {
        headers: { Authorization: `Bearer ${this.accessToken}` }
      });

      return response.data;
    } catch (error) {
      // Token expired - try refresh
      if (this.refreshToken) {
        await this.refreshAccessToken();
        return this.getSession();
      }
      this.clearTokens();
      return null;
    }
  }

  async refreshAccessToken() {
    if (!this.refreshToken) throw new Error('No refresh token');

    const response = await axios.post(`${SSO_SERVER_URL}/api/auth/token`, {
      grant_type: 'refresh_token',
      refresh_token: this.refreshToken,
      client_id: CLIENT_ID,
      client_secret: CLIENT_SECRET,
    });

    const { access_token, refresh_token } = response.data;
    this.saveTokens(access_token, refresh_token);

    return access_token;
  }

  async logout() {
    if (this.accessToken) {
      try {
        await axios.post(
          `${SSO_SERVER_URL}/api/auth/logout`,
          { access_token: this.accessToken },
          { headers: { Authorization: `Bearer ${this.accessToken}` } }
        );
      } catch (error) {
        console.error('Logout request failed:', error);
      }
    }

    this.clearTokens();
  }

  isAuthenticated(): boolean {
    return !!this.accessToken;
  }

  getStoredTokens() {
    return {
      accessToken: this.accessToken,
      refreshToken: this.refreshToken,
    };
  }
}

export const authService = new AuthService();
```

### React Hook for Authentication

Create a custom hook for authentication state:

```typescript
// hooks/useAuth.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { authService } from '../services/authService';

interface AuthContextType {
  isAuthenticated: boolean;
  session: Session | null;
  login: (address: string) => Promise<void>;
  logout: () => Promise<void>;
  loading: boolean;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const session = await authService.getSession();
      if (session) {
        setIsAuthenticated(true);
        setSession(session);
      }
    } catch (error) {
      console.error('Auth check failed:', error);
    } finally {
      setLoading(false);
    }
  };

  const login = async (address: string) => {
    // Will be called after wallet signature
    await checkAuth();
  };

  const logout = async () => {
    await authService.logout();
    setIsAuthenticated(false);
    setSession(null);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, session, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### Wallet Connection Hook

Handle wallet interactions:

```typescript
// hooks/useWallet.tsx
import { useState, useEffect } from 'react';
import { web3Enable, web3Accounts, web3FromAddress } from '@polkadot/extension-dapp';
import { authService } from '../services/authService';

export function useWallet() {
  const [accounts, setAccounts] = useState<any[]>([]);
  const [selectedAccount, setSelectedAccount] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    connectWallet();
  }, []);

  const connectWallet = async () => {
    try {
      setLoading(true);
      const extensions = await web3Enable('Polkadot SSO Demo');

      if (extensions.length === 0) {
        setError('No wallet extension found. Please install Polkadot.js');
        return;
      }

      const allAccounts = await web3Accounts();
      setAccounts(allAccounts);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to connect wallet');
    } finally {
      setLoading(false);
    }
  };

  const signIn = async (account: any) => {
    try {
      setLoading(true);
      setError(null);

      // 1. Create challenge
      const challenge = await authService.createChallenge(account.address);

      // 2. Request signature
      const injector = await web3FromAddress(account.address);
      const signRaw = injector?.signer?.signRaw;

      if (!signRaw) {
        throw new Error('Wallet does not support message signing');
      }

      const { signature } = await signRaw({
        address: account.address,
        data: challenge.message,
        type: 'bytes'
      });

      // 3. Verify signature
      const result = await authService.verifySignature(
        signature,
        challenge.id,
        account.address
      );

      if (result.success) {
        setSelectedAccount(account);
        return true;
      }

      return false;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Sign in failed');
      return false;
    } finally {
      setLoading(false);
    }
  };

  return {
    accounts,
    selectedAccount,
    loading,
    error,
    connectWallet,
    signIn,
  };
}
```

### Login Component

Complete login UI component:

```tsx
// components/LoginPage.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useWallet } from '../hooks/useWallet';
import { useAuth } from '../hooks/useAuth';

export function LoginPage() {
  const navigate = useNavigate();
  const { accounts, loading, error, signIn } = useWallet();
  const { login } = useAuth();
  const [selectedAddress, setSelectedAddress] = useState('');
  const [signing, setSigning] = useState(false);

  const handleSignIn = async () => {
    if (!selectedAddress) return;

    setSigning(true);
    const account = accounts.find(a => a.address === selectedAddress);

    if (account) {
      const success = await signIn(account);
      if (success) {
        await login(account.address);
        navigate('/dashboard');
      }
    }

    setSigning(false);
  };

  if (loading) {
    return <div>Connecting to wallet...</div>;
  }

  if (error) {
    return (
      <div className="error">
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>
          Retry
        </button>
      </div>
    );
  }

  if (accounts.length === 0) {
    return (
      <div>
        <p>No accounts found.</p>
        <p>Please install Polkadot.js extension and create an account.</p>
      </div>
    );
  }

  return (
    <div className="login-container">
      <h1>Sign In with Polkadot</h1>

      <div className="account-selector">
        <label>Select Account:</label>
        <select
          value={selectedAddress}
          onChange={(e) => setSelectedAddress(e.target.value)}
          disabled={signing}
        >
          <option value="">Choose an account</option>
          {accounts.map((account) => (
            <option key={account.address} value={account.address}>
              {account.meta.name || account.address}
            </option>
          ))}
        </select>
      </div>

      <button
        onClick={handleSignIn}
        disabled={!selectedAddress || signing}
        className="sign-in-button"
      >
        {signing ? 'Signing...' : 'Sign In'}
      </button>
    </div>
  );
}
```

### Protected Route Component

Protect authenticated routes:

```tsx
// components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useAuth } from '../hooks/useAuth';

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    return <div>Loading...</div>;
  }

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}
```

### App Component

Wire everything together:

```tsx
// App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './hooks/useAuth';
import { LoginPage } from './components/LoginPage';
import { DashboardPage } from './components/DashboardPage';
import { CallbackPage } from './components/CallbackPage';
import { ProtectedRoute } from './components/ProtectedRoute';

export default function App() {
  return (
    <BrowserRouter>
      <AuthProvider>
        <Routes>
          <Route path="/login" element={<LoginPage />} />
          <Route path="/callback" element={<CallbackPage />} />
          <Route
            path="/dashboard"
            element={
              <ProtectedRoute>
                <DashboardPage />
              </ProtectedRoute>
            }
          />
          <Route path="/" element={<Navigate to="/login" />} />
        </Routes>
      </AuthProvider>
    </BrowserRouter>
  );
}
```

## Vue.js Integration

Similar implementation for Vue 3:

```vue
<!-- stores/auth.ts -->
<script setup lang="ts">
import { defineStore } from 'pinia';
import { ref, computed } from 'vue';
import { authService } from '@/services/authService';

export const useAuthStore = defineStore('auth', () => {
  const session = ref(null);
  const loading = ref(false);

  const isAuthenticated = computed(() => !!session.value);

  async function checkAuth() {
    loading.value = true;
    try {
      session.value = await authService.getSession();
    } finally {
      loading.value = false;
    }
  }

  async function login(address: string) {
    // Implement login flow
  }

  async function logout() {
    await authService.logout();
    session.value = null;
  }

  return {
    session,
    loading,
    isAuthenticated,
    checkAuth,
    login,
    logout
  };
});
</script>
```

## Next.js Integration

Server-side authentication with Next.js:

```typescript
// pages/api/auth/[...auth].ts
import { NextApiRequest, NextApiResponse } from 'next';
import axios from 'axios';

const SSO_URL = process.env.SSO_SERVER_URL;

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { auth } = req.query;

  if (auth[0] === 'login') {
    // Proxy to SSO server
    const response = await axios.get(`${SSO_URL}/api/auth/challenge`, {
      params: req.query
    });
    res.send(response.data);
  }

  // Handle other auth routes...
}
```

## Error Handling

Implement comprehensive error handling:

```typescript
class AuthError extends Error {
  code: string;
  details?: any;

  constructor(message: string, code: string, details?: any) {
    super(message);
    this.code = code;
    this.details = details;
  }
}

// In your auth service
async function handleAuthError(error: any) {
  if (error.response) {
    const { status, data } = error.response;

    switch (status) {
      case 401:
        throw new AuthError('Authentication failed', 'AUTH_FAILED', data);
      case 403:
        throw new AuthError('Access forbidden', 'ACCESS_DENIED', data);
      case 429:
        throw new AuthError('Too many requests', 'RATE_LIMITED', data);
      default:
        throw new AuthError('Authentication error', 'UNKNOWN', data);
    }
  }

  throw error;
}
```

## Best Practices

1. **Token Storage**: Use httpOnly cookies in production instead of localStorage
2. **Token Refresh**: Implement automatic token refresh before expiry
3. **Error Recovery**: Handle network failures gracefully
4. **Loading States**: Show appropriate loading indicators
5. **Wallet Detection**: Check for wallet availability before auth
6. **Session Persistence**: Maintain session across page refreshes
7. **Security**: Never expose client secrets in frontend code