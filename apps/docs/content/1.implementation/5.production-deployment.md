---
title: Production Deployment
description: Deploy Polkadot SSO to production environments
---

# Production Deployment

This guide covers deploying Polkadot SSO to production environments with proper security, scaling, and monitoring.

## Environment Configuration

### Required Environment Variables

```env
# Security - REQUIRED (generate secure random strings)
SESSION_SECRET=<64-character-random-string>
JWT_ACCESS_SECRET=<64-character-random-string>
JWT_REFRESH_SECRET=<64-character-random-string>

# Server Configuration
NODE_ENV=production
PORT=3001
HOST=0.0.0.0

# Database
DATABASE_PATH=/var/lib/polkadot-sso/sso.db
DATABASE_BACKUP_PATH=/var/lib/polkadot-sso/backups

# CORS - Update with your domains
ALLOWED_ORIGINS=https://app.example.com,https://www.example.com

# JWT Configuration
JWT_ACCESS_TTL=15m
JWT_REFRESH_TTL=7d
JWT_ISSUER=https://sso.example.com
JWT_AUDIENCE=https://app.example.com

# Rate Limiting
RATE_LIMIT_WINDOW_MS=60000
RATE_LIMIT_MAX_REQUESTS=100

# Logging
LOG_LEVEL=info
LOG_FILE=/var/log/polkadot-sso/app.log

# Monitoring
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
PROMETHEUS_PORT=9090

# Redis (optional, for session storage)
REDIS_URL=redis://:password@localhost:6379
```

### Generate Secure Secrets

```bash
# Generate secure random strings
openssl rand -hex 32  # For SESSION_SECRET
openssl rand -hex 32  # For JWT_ACCESS_SECRET
openssl rand -hex 32  # For JWT_REFRESH_SECRET

# Or using Node.js
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

## Build and Optimization

### Build for Production

```bash
# Install dependencies
cd apps/sso
bun install --production

# Build the application
bun run build

# Output will be in dist/ directory
ls -la dist/
```

### Bundle Optimization

The SSO service uses `tsdown` for optimal bundling:

```json
// package.json build script
{
  "scripts": {
    "build": "tsdown src/index.ts --outDir dist --minify --format esm"
  }
}
```

## Deployment Options

### Option 1: Docker Deployment

Create a production Dockerfile:

```dockerfile
# Dockerfile
FROM oven/bun:1.2.22-alpine AS base
WORKDIR /app

# Install dependencies
FROM base AS deps
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile --production

# Build application
FROM base AS build
COPY package.json bun.lockb ./
RUN bun install --frozen-lockfile
COPY . .
RUN bun run build

# Production image
FROM base AS runtime
ENV NODE_ENV=production
WORKDIR /app

# Create non-root user
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Copy built application
COPY --from=deps --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nodejs:nodejs /app/dist ./dist
COPY --from=build --chown=nodejs:nodejs /app/package.json ./

# Create data directory
RUN mkdir -p /var/lib/polkadot-sso && \
    chown -R nodejs:nodejs /var/lib/polkadot-sso

USER nodejs
EXPOSE 3001

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3001/health', (r) => {r.statusCode === 200 ? process.exit(0) : process.exit(1)})"

CMD ["bun", "dist/index.js"]
```

Build and run:

```bash
# Build Docker image
docker build -t polkadot-sso:latest .

# Run container
docker run -d \
  --name polkadot-sso \
  -p 3001:3001 \
  --env-file .env.production \
  -v /var/lib/polkadot-sso:/var/lib/polkadot-sso \
  polkadot-sso:latest
```

### Option 2: PM2 Deployment

Use PM2 for process management:

```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'polkadot-sso',
    script: './dist/index.js',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: 'production',
      PORT: 3001
    },
    error_file: '/var/log/polkadot-sso/error.log',
    out_file: '/var/log/polkadot-sso/out.log',
    log_file: '/var/log/polkadot-sso/combined.log',
    time: true,
    max_memory_restart: '1G',
    min_uptime: '10s',
    max_restarts: 10,
    autorestart: true,
    watch: false,
    vizion: false,
  }]
};
```

Deploy with PM2:

```bash
# Install PM2 globally
npm install -g pm2

# Start application
pm2 start ecosystem.config.js

# Save PM2 configuration
pm2 save

# Setup startup script
pm2 startup

# Monitor
pm2 monit
```

### Option 3: Systemd Service

Create a systemd service:

```ini
# /etc/systemd/system/polkadot-sso.service
[Unit]
Description=Polkadot SSO Authentication Service
After=network.target

[Service]
Type=simple
User=nodejs
Group=nodejs
WorkingDirectory=/opt/polkadot-sso
ExecStart=/usr/local/bin/bun /opt/polkadot-sso/dist/index.js
Restart=always
RestartSec=10

# Environment
EnvironmentFile=/opt/polkadot-sso/.env.production

# Security
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths=/var/lib/polkadot-sso /var/log/polkadot-sso

# Logging
StandardOutput=append:/var/log/polkadot-sso/output.log
StandardError=append:/var/log/polkadot-sso/error.log

[Install]
WantedBy=multi-user.target
```

Enable and start:

```bash
# Reload systemd
sudo systemctl daemon-reload

# Enable service
sudo systemctl enable polkadot-sso

# Start service
sudo systemctl start polkadot-sso

# Check status
sudo systemctl status polkadot-sso
```

## Reverse Proxy Configuration

### Nginx Configuration

```nginx
# /etc/nginx/sites-available/polkadot-sso
upstream polkadot_sso {
    least_conn;
    server 127.0.0.1:3001 max_fails=3 fail_timeout=30s;
    # Add more servers for load balancing
    # server 127.0.0.1:3002 max_fails=3 fail_timeout=30s;
}

# Rate limiting zones
limit_req_zone $binary_remote_addr zone=auth_limit:10m rate=10r/s;
limit_conn_zone $binary_remote_addr zone=conn_limit:10m;

server {
    listen 80;
    server_name sso.example.com;

    # Redirect to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name sso.example.com;

    # SSL Configuration
    ssl_certificate /etc/letsencrypt/live/sso.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/sso.example.com/privkey.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Modern SSL configuration
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # HSTS
    add_header Strict-Transport-Security "max-age=63072000" always;

    # Security headers
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;

    # Rate limiting
    limit_req zone=auth_limit burst=20 nodelay;
    limit_conn conn_limit 100;

    # Proxy configuration
    location /api/auth {
        proxy_pass http://polkadot_sso;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;

        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;

        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
    }

    # Health check endpoint
    location /health {
        proxy_pass http://polkadot_sso;
        access_log off;
    }

    # Block sensitive paths
    location ~ /\. {
        deny all;
    }
}
```

### Apache Configuration

```apache
# /etc/apache2/sites-available/polkadot-sso.conf
<VirtualHost *:443>
    ServerName sso.example.com

    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/sso.example.com/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/sso.example.com/privkey.pem

    # Security Headers
    Header always set X-Frame-Options "DENY"
    Header always set X-Content-Type-Options "nosniff"
    Header always set Strict-Transport-Security "max-age=63072000"

    # Proxy Configuration
    ProxyPreserveHost On
    ProxyPass /api/auth http://localhost:3001/api/auth
    ProxyPassReverse /api/auth http://localhost:3001/api/auth

    # Rate limiting
    <Location /api/auth>
        SetOutputFilter RATE_LIMIT
        SetEnv rate-limit 100
    </Location>
</VirtualHost>
```

## Database Management

### SQLite Production Setup

```bash
# Create database directory with proper permissions
sudo mkdir -p /var/lib/polkadot-sso
sudo chown nodejs:nodejs /var/lib/polkadot-sso

# Set up automated backups
cat > /etc/cron.d/polkadot-sso-backup << EOF
0 2 * * * nodejs sqlite3 /var/lib/polkadot-sso/sso.db ".backup /var/lib/polkadot-sso/backups/sso-\$(date +\%Y\%m\%d).db"
0 3 * * * nodejs find /var/lib/polkadot-sso/backups -name "*.db" -mtime +30 -delete
EOF
```

### Migration to PostgreSQL (Optional)

For high-traffic deployments:

```sql
-- PostgreSQL schema
CREATE DATABASE polkadot_sso;

CREATE TABLE challenges (
    id VARCHAR(255) PRIMARY KEY,
    address VARCHAR(255) NOT NULL,
    message TEXT NOT NULL,
    code_challenge VARCHAR(255) NOT NULL,
    state VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    used BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE sessions (
    id VARCHAR(255) PRIMARY KEY,
    address VARCHAR(255) NOT NULL,
    access_token TEXT NOT NULL,
    refresh_token TEXT NOT NULL,
    client_id VARCHAR(255) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Indexes
CREATE INDEX idx_challenges_address ON challenges(address);
CREATE INDEX idx_challenges_expires ON challenges(expires_at);
CREATE INDEX idx_sessions_address ON sessions(address);
CREATE INDEX idx_sessions_token ON sessions(access_token);
```

## Monitoring

### Health Monitoring

```typescript
// healthcheck.ts
import axios from 'axios';

async function checkHealth() {
  try {
    const response = await axios.get('https://sso.example.com/health');

    if (response.data.status !== 'healthy') {
      // Alert administrators
      await sendAlert('SSO service unhealthy', response.data);
    }
  } catch (error) {
    // Service is down
    await sendAlert('SSO service down', error.message);
  }
}

// Run every minute
setInterval(checkHealth, 60000);
```

### Prometheus Metrics

```yaml
# prometheus.yml
scrape_configs:
  - job_name: 'polkadot-sso'
    static_configs:
      - targets: ['localhost:9090']
    metrics_path: '/metrics'
```

### Logging with Winston

```typescript
// Enhanced logging configuration
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'polkadot-sso' },
  transports: [
    new winston.transports.File({
      filename: '/var/log/polkadot-sso/error.log',
      level: 'error'
    }),
    new winston.transports.File({
      filename: '/var/log/polkadot-sso/combined.log'
    }),
    new winston.transports.Console({
      format: winston.format.simple()
    })
  ]
});
```

## Security Hardening

### Linux Security

```bash
# Set up firewall
sudo ufw allow 22/tcp
sudo ufw allow 443/tcp
sudo ufw allow 80/tcp
sudo ufw enable

# Fail2ban configuration
cat > /etc/fail2ban/jail.d/polkadot-sso.conf << EOF
[polkadot-sso]
enabled = true
port = https
filter = polkadot-sso
logpath = /var/log/polkadot-sso/access.log
maxretry = 5
findtime = 600
bantime = 3600
EOF
```

### Application Security

```typescript
// Additional security middleware
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  }
}));
```

## Performance Optimization

### Caching Strategy

```typescript
// Redis caching for sessions
import Redis from 'ioredis';

const redis = new Redis(process.env.REDIS_URL);

// Cache session lookups
async function getSession(token: string) {
  // Check cache first
  const cached = await redis.get(`session:${token}`);
  if (cached) return JSON.parse(cached);

  // Fetch from database
  const session = await db.getSession(token);

  // Cache for 5 minutes
  await redis.set(
    `session:${token}`,
    JSON.stringify(session),
    'EX',
    300
  );

  return session;
}
```

### Load Testing

```bash
# Test with Apache Bench
ab -n 10000 -c 100 https://sso.example.com/health

# Test with k6
k6 run load-test.js
```

## Backup and Recovery

### Automated Backups

```bash
#!/bin/bash
# backup.sh
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/var/backups/polkadot-sso"

# Database backup
sqlite3 /var/lib/polkadot-sso/sso.db ".backup ${BACKUP_DIR}/sso_${DATE}.db"

# Configuration backup
tar -czf ${BACKUP_DIR}/config_${DATE}.tar.gz /opt/polkadot-sso/.env.production

# Upload to S3 (optional)
aws s3 cp ${BACKUP_DIR}/sso_${DATE}.db s3://my-backup-bucket/polkadot-sso/

# Clean old backups (keep 30 days)
find ${BACKUP_DIR} -name "*.db" -mtime +30 -delete
```

## Deployment Checklist

- [ ] Generate secure random secrets
- [ ] Configure environment variables
- [ ] Set up SSL certificates
- [ ] Configure reverse proxy
- [ ] Set up database and backups
- [ ] Configure logging
- [ ] Set up monitoring
- [ ] Configure firewall rules
- [ ] Set up rate limiting
- [ ] Test authentication flow
- [ ] Load test the deployment
- [ ] Document deployment procedures
- [ ] Set up incident response plan