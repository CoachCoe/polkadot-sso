---
title: Production Deployment
description: Production deployment guide for Polkadot SSO with Better Auth
---

# Production Deployment

This guide covers deploying Polkadot SSO with Better Auth in production environments.

## Prerequisites

- Node.js 18+ and npm
- Database (SQLite, PostgreSQL, or MySQL)
- Domain name and SSL certificate
- Environment variables configured

## Environment Setup

### 1. Environment Variables

Create a production `.env` file:

```bash
# Required
NODE_ENV=production
SESSION_SECRET=your-32-character-session-secret
DATABASE_URL=postgresql://user:password@localhost:5432/polkadot_sso

# Optional - Chain RPC URLs
POLKADOT_RPC_URL=wss://rpc.polkadot.io
KUSAMA_RPC_URL=wss://kusama-rpc.polkadot.io
WESTEND_RPC_URL=wss://westend-rpc.polkadot.io

# Optional - Server Configuration
PORT=3001
HOST=0.0.0.0
```

### 2. Database Setup

#### PostgreSQL (Recommended)

```sql
-- Create database
CREATE DATABASE polkadot_sso;

-- Create user
CREATE USER polkadot_sso_user WITH PASSWORD 'secure_password';

-- Grant permissions
GRANT ALL PRIVILEGES ON DATABASE polkadot_sso TO polkadot_sso_user;
```

#### MySQL

```sql
-- Create database
CREATE DATABASE polkadot_sso;

-- Create user
CREATE USER 'polkadot_sso_user'@'localhost' IDENTIFIED BY 'secure_password';

-- Grant permissions
GRANT ALL PRIVILEGES ON polkadot_sso.* TO 'polkadot_sso_user'@'localhost';
FLUSH PRIVILEGES;
```

## Docker Deployment

### 1. Dockerfile

```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./
RUN npm ci --only=production

# Copy source code
COPY . .

# Build application
RUN npm run build

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S polkadot -u 1001

# Change ownership
RUN chown -R polkadot:nodejs /app
USER polkadot

# Expose port
EXPOSE 3001

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3001/health || exit 1

# Start application
CMD ["npm", "start"]
```

### 2. Docker Compose

```yaml
version: '3.8'

services:
  polkadot-sso:
    build: .
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - SESSION_SECRET=${SESSION_SECRET}
      - DATABASE_URL=postgresql://polkadot_sso_user:${DB_PASSWORD}@postgres:5432/polkadot_sso
    depends_on:
      - postgres
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=polkadot_sso
      - POSTGRES_USER=polkadot_sso_user
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - polkadot-sso
    restart: unless-stopped

volumes:
  postgres_data:
```

### 3. Nginx Configuration

```nginx
events {
    worker_connections 1024;
}

http {
    upstream polkadot_sso {
        server polkadot-sso:3001;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;

    server {
        listen 80;
        server_name your-domain.com;
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name your-domain.com;

        # SSL Configuration
        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
        ssl_prefer_server_ciphers off;

        # Security Headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Strict-Transport-Security "max-age=63072000" always;

        # API Routes
        location /api/auth {
            limit_req zone=api burst=20 nodelay;
            proxy_pass http://polkadot_sso;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Health Check
        location /health {
            proxy_pass http://polkadot_sso;
            access_log off;
        }
    }
}
```

## Kubernetes Deployment

### 1. Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: polkadot-sso
spec:
  replicas: 3
  selector:
    matchLabels:
      app: polkadot-sso
  template:
    metadata:
      labels:
        app: polkadot-sso
    spec:
      containers:
      - name: polkadot-sso
        image: polkadot-sso:latest
        ports:
        - containerPort: 3001
        env:
        - name: NODE_ENV
          value: "production"
        - name: SESSION_SECRET
          valueFrom:
            secretKeyRef:
              name: polkadot-sso-secrets
              key: session-secret
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: polkadot-sso-secrets
              key: database-url
        livenessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 3001
          initialDelaySeconds: 5
          periodSeconds: 5
```

### 2. Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: polkadot-sso-service
spec:
  selector:
    app: polkadot-sso
  ports:
  - protocol: TCP
    port: 80
    targetPort: 3001
  type: LoadBalancer
```

### 3. Secrets

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: polkadot-sso-secrets
type: Opaque
data:
  session-secret: <base64-encoded-secret>
  database-url: <base64-encoded-url>
```

## Cloud Deployment

### 1. AWS ECS

```json
{
  "family": "polkadot-sso",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::account:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::account:role/ecsTaskRole",
  "containerDefinitions": [
    {
      "name": "polkadot-sso",
      "image": "your-account.dkr.ecr.region.amazonaws.com/polkadot-sso:latest",
      "portMappings": [
        {
          "containerPort": 3001,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        }
      ],
      "secrets": [
        {
          "name": "SESSION_SECRET",
          "valueFrom": "arn:aws:secretsmanager:region:account:secret:polkadot-sso/session-secret"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/polkadot-sso",
          "awslogs-region": "us-west-2",
          "awslogs-stream-prefix": "ecs"
        }
      }
    }
  ]
}
```

### 2. Google Cloud Run

```yaml
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: polkadot-sso
  annotations:
    run.googleapis.com/ingress: all
spec:
  template:
    metadata:
      annotations:
        autoscaling.knative.dev/maxScale: "10"
        run.googleapis.com/execution-environment: gen2
    spec:
      containerConcurrency: 100
      containers:
      - image: gcr.io/your-project/polkadot-sso:latest
        ports:
        - containerPort: 3001
        env:
        - name: NODE_ENV
          value: "production"
        - name: SESSION_SECRET
          valueFrom:
            secretKeyRef:
              name: polkadot-sso-secrets
              key: session-secret
        resources:
          limits:
            cpu: "1"
            memory: "512Mi"
```

## Monitoring and Logging

### 1. Health Checks

```typescript
// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    version: process.env.npm_package_version
  })
})
```

### 2. Logging

```typescript
import winston from 'winston'

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
})

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.simple()
  }))
}
```

### 3. Metrics

```typescript
import prometheus from 'prom-client'

const httpRequestDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status']
})

const authAttempts = new prometheus.Counter({
  name: 'auth_attempts_total',
  help: 'Total number of authentication attempts',
  labelNames: ['status', 'chain']
})
```

## Security Considerations

### 1. Environment Security

- Use strong, unique session secrets
- Enable HTTPS with proper SSL certificates
- Implement proper CORS policies
- Use secure database connections
- Regular security updates

### 2. Network Security

- Implement firewall rules
- Use VPCs for cloud deployments
- Enable DDoS protection
- Monitor network traffic
- Implement rate limiting

### 3. Application Security

- Enable security headers
- Implement input validation
- Use secure session management
- Regular security audits
- Monitor for vulnerabilities

## Backup and Recovery

### 1. Database Backups

```bash
# PostgreSQL backup
pg_dump -h localhost -U polkadot_sso_user polkadot_sso > backup.sql

# Automated backup script
#!/bin/bash
DATE=$(date +%Y%m%d_%H%M%S)
pg_dump -h localhost -U polkadot_sso_user polkadot_sso > "backup_${DATE}.sql"
aws s3 cp "backup_${DATE}.sql" s3://your-backup-bucket/
```

### 2. Disaster Recovery

- Regular automated backups
- Cross-region backup replication
- Recovery time objectives (RTO)
- Recovery point objectives (RPO)
- Testing recovery procedures

## Performance Optimization

### 1. Caching

```typescript
import Redis from 'ioredis'

const redis = new Redis(process.env.REDIS_URL)

// Cache challenge data
await redis.setex(`challenge:${challengeId}`, 300, JSON.stringify(challenge))

// Cache user sessions
await redis.setex(`session:${sessionId}`, 900, JSON.stringify(session))
```

### 2. Database Optimization

- Proper indexing
- Connection pooling
- Query optimization
- Regular maintenance
- Monitoring performance

### 3. Load Balancing

- Multiple application instances
- Health check endpoints
- Session affinity (if needed)
- Auto-scaling policies
- Traffic distribution