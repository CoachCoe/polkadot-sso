---
title: Security Best Practices
description: Security guidelines and best practices for Polkadot SSO
---

# Security Best Practices

This guide covers security best practices for implementing and deploying Polkadot SSO.

## Authentication Security

### Challenge Generation

The SSO server implements secure challenge generation:

```typescript
// Secure challenge generation
function generateChallenge(): Challenge {
  // Use cryptographically secure random values
  const challengeId = crypto.randomBytes(16).toString('hex');
  const nonce = crypto.randomBytes(32).toString('base64');

  // Include timestamp to prevent replay attacks
  const timestamp = Date.now();

  // Set short expiration (5 minutes)
  const expiresAt = new Date(timestamp + 5 * 60 * 1000);

  // PKCE parameters for additional security
  const codeVerifier = generateCodeVerifier(); // 128 chars
  const codeChallenge = sha256(codeVerifier);

  return {
    id: challengeId,
    nonce,
    timestamp,
    expiresAt,
    codeVerifier,
    codeChallenge
  };
}
```

### Signature Verification

Proper signature verification using Polkadot cryptography:

```typescript
import { cryptoWaitReady, signatureVerify } from '@polkadot/util-crypto';

async function verifySignature(
  signature: string,
  message: string,
  address: string
): Promise<boolean> {
  await cryptoWaitReady();

  try {
    const verification = signatureVerify(message, signature, address);

    if (!verification.isValid) {
      logger.warn('Invalid signature attempt', {
        address,
        signature: signature.substring(0, 10) + '...'
      });
      return false;
    }

    // Additional checks
    const challenge = await getChallengeForAddress(address);

    // Verify challenge hasn't expired
    if (new Date() > new Date(challenge.expiresAt)) {
      throw new Error('Challenge expired');
    }

    // Verify challenge hasn't been used
    if (challenge.used) {
      throw new Error('Challenge already used');
    }

    // Mark challenge as used immediately
    await markChallengeUsed(challenge.id);

    return true;
  } catch (error) {
    logger.error('Signature verification error', error);
    return false;
  }
}
```

## Token Security

### JWT Best Practices

```typescript
// Secure JWT configuration
const jwtConfig = {
  access: {
    secret: process.env.JWT_ACCESS_SECRET, // Min 256 bits
    expiresIn: '15m', // Short-lived access tokens
    algorithm: 'HS256',
    issuer: 'https://sso.example.com',
    audience: 'https://app.example.com'
  },
  refresh: {
    secret: process.env.JWT_REFRESH_SECRET, // Different secret
    expiresIn: '7d', // Longer-lived refresh tokens
    algorithm: 'HS256',
    issuer: 'https://sso.example.com',
    audience: 'https://app.example.com'
  }
};

// Token generation with claims
function generateAccessToken(session: Session): string {
  return jwt.sign(
    {
      sub: session.address, // Subject
      sid: session.id, // Session ID
      type: 'access',
      iat: Math.floor(Date.now() / 1000), // Issued at
      jti: crypto.randomBytes(16).toString('hex') // JWT ID
    },
    jwtConfig.access.secret,
    {
      expiresIn: jwtConfig.access.expiresIn,
      algorithm: jwtConfig.access.algorithm,
      issuer: jwtConfig.access.issuer,
      audience: jwtConfig.access.audience
    }
  );
}
```

### Token Rotation

Implement refresh token rotation:

```typescript
async function refreshTokenRotation(refreshToken: string) {
  // Verify refresh token
  const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET);

  // Check if token is in database (not revoked)
  const session = await db.getSessionByRefreshToken(refreshToken);
  if (!session) {
    throw new Error('Invalid refresh token');
  }

  // Revoke old refresh token
  await db.revokeRefreshToken(refreshToken);

  // Generate new token pair
  const newAccessToken = generateAccessToken(session);
  const newRefreshToken = generateRefreshToken(session);

  // Save new refresh token
  await db.saveRefreshToken(session.id, newRefreshToken);

  // Log token rotation for audit
  await auditLog('token_rotated', {
    sessionId: session.id,
    address: session.address
  });

  return {
    access_token: newAccessToken,
    refresh_token: newRefreshToken
  };
}
```

## Input Validation

### Schema Validation with Zod

```typescript
import { z } from 'zod';

// Challenge request validation
const challengeSchema = z.object({
  client_id: z.string()
    .min(1)
    .max(255)
    .regex(/^[a-zA-Z0-9-_]+$/),
  address: z.string()
    .regex(/^[1-9A-HJ-NP-Za-km-z]{48,}$/), // Polkadot address format
  chain: z.enum(['polkadot', 'kusama', 'westend'])
    .optional()
    .default('westend')
});

// Verification request validation
const verificationSchema = z.object({
  signature: z.string()
    .regex(/^0x[a-fA-F0-9]+$/),
  challenge_id: z.string()
    .length(32),
  address: z.string()
    .regex(/^[1-9A-HJ-NP-Za-km-z]{48,}$/),
  code_verifier: z.string()
    .length(128)
    .regex(/^[A-Za-z0-9-._~]+$/), // PKCE charset
  state: z.string()
    .min(32)
    .max(256)
});

// Middleware for validation
function validateRequest(schema: z.ZodSchema) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      const validated = schema.parse(req.body || req.query);
      req.validated = validated;
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          error: 'validation_error',
          details: error.errors
        });
      }
      next(error);
    }
  };
}
```

### SQL Injection Prevention

```typescript
// Use parameterized queries
class DatabaseService {
  async getChallenge(challengeId: string) {
    // SAFE: Parameterized query
    return await this.db.get(
      'SELECT * FROM challenges WHERE id = ? AND used = 0',
      [challengeId]
    );
  }

  async createSession(session: Session) {
    // SAFE: Using prepared statement
    const stmt = await this.db.prepare(`
      INSERT INTO sessions (id, address, access_token, refresh_token, expires_at)
      VALUES (?, ?, ?, ?, ?)
    `);

    return await stmt.run(
      session.id,
      session.address,
      session.accessToken,
      session.refreshToken,
      session.expiresAt
    );
  }
}
```

## Rate Limiting

### Comprehensive Rate Limiting

```typescript
import rateLimit from 'express-rate-limit';
import RedisStore from 'rate-limit-redis';

// Different limits for different endpoints
const rateLimits = {
  // Strict limit for challenge creation
  challenge: rateLimit({
    store: new RedisStore({ client: redis }),
    windowMs: 60 * 1000, // 1 minute
    max: 10, // 10 requests per minute
    message: 'Too many challenge requests',
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => req.ip + ':' + req.query.address
  }),

  // Very strict for verification
  verify: rateLimit({
    store: new RedisStore({ client: redis }),
    windowMs: 60 * 1000,
    max: 5, // 5 attempts per minute
    message: 'Too many verification attempts',
    skipSuccessfulRequests: true // Don't count successful verifications
  }),

  // Moderate for token exchange
  token: rateLimit({
    windowMs: 60 * 1000,
    max: 10,
    message: 'Too many token requests'
  }),

  // Global rate limit
  global: rateLimit({
    windowMs: 60 * 1000,
    max: 100,
    message: 'Too many requests from this IP'
  })
};

// Apply rate limits
app.use('/api/auth', rateLimits.global);
app.use('/api/auth/challenge', rateLimits.challenge);
app.use('/api/auth/verify', rateLimits.verify);
app.use('/api/auth/token', rateLimits.token);
```

## CSRF Protection

### State Parameter Validation

```typescript
// Generate and validate state parameter
class CSRFProtection {
  private states = new Map<string, StateData>();

  generateState(clientId: string): string {
    const state = crypto.randomBytes(32).toString('base64url');

    this.states.set(state, {
      clientId,
      createdAt: Date.now(),
      used: false
    });

    // Clean old states
    this.cleanupStates();

    return state;
  }

  validateState(state: string, clientId: string): boolean {
    const stateData = this.states.get(state);

    if (!stateData) {
      return false;
    }

    // Check if state matches client
    if (stateData.clientId !== clientId) {
      return false;
    }

    // Check if state is expired (5 minutes)
    if (Date.now() - stateData.createdAt > 5 * 60 * 1000) {
      this.states.delete(state);
      return false;
    }

    // Check if already used
    if (stateData.used) {
      return false;
    }

    // Mark as used
    stateData.used = true;

    return true;
  }

  private cleanupStates() {
    const now = Date.now();
    for (const [state, data] of this.states) {
      if (now - data.createdAt > 10 * 60 * 1000) {
        this.states.delete(state);
      }
    }
  }
}
```

## Security Headers

### Comprehensive Security Headers

```typescript
import helmet from 'helmet';

app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'sha256-...'"], // Add specific hashes
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'none'"],
      frameSrc: ["'none'"],
      sandbox: ['allow-forms', 'allow-scripts', 'allow-same-origin'],
      reportUri: '/api/csp-report',
      upgradeInsecureRequests: []
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  xssFilter: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' },
  permittedCrossDomainPolicies: false
}));

// Additional security headers
app.use((req, res, next) => {
  res.setHeader('X-Permitted-Cross-Domain-Policies', 'none');
  res.setHeader('Expect-CT', 'enforce, max-age=86400');
  res.setHeader('Feature-Policy', "camera 'none'; microphone 'none'");
  next();
});
```

## Audit Logging

### Comprehensive Audit Trail

```typescript
class AuditLogger {
  async log(event: AuditEvent) {
    const entry = {
      id: crypto.randomUUID(),
      timestamp: new Date().toISOString(),
      type: event.type,
      severity: event.severity || 'info',
      user: event.user,
      ip: event.ip,
      userAgent: event.userAgent,
      action: event.action,
      result: event.result,
      details: event.details,
      requestId: event.requestId
    };

    // Log to database
    await db.run(`
      INSERT INTO audit_logs
      (id, timestamp, type, severity, user, ip, action, result, details)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `, [
      entry.id,
      entry.timestamp,
      entry.type,
      entry.severity,
      entry.user,
      entry.ip,
      entry.action,
      entry.result,
      JSON.stringify(entry.details)
    ]);

    // Log to file for backup
    logger.info('AUDIT', entry);

    // Alert on critical events
    if (entry.severity === 'critical') {
      await this.sendAlert(entry);
    }
  }

  // Events to audit
  async logAuthenticationAttempt(req: Request, success: boolean) {
    await this.log({
      type: 'AUTHENTICATION',
      severity: success ? 'info' : 'warning',
      user: req.body.address,
      ip: req.ip,
      userAgent: req.get('User-Agent'),
      action: 'login_attempt',
      result: success ? 'success' : 'failure',
      details: {
        clientId: req.body.client_id,
        challenge: req.body.challenge_id
      },
      requestId: req.id
    });
  }
}
```

## Session Security

### Secure Session Management

```typescript
class SessionManager {
  // Session configuration
  private readonly SESSION_TIMEOUT = 15 * 60 * 1000; // 15 minutes
  private readonly MAX_SESSIONS_PER_USER = 5;

  async createSession(address: string, clientId: string) {
    // Check existing sessions
    const existingSessions = await this.getActiveSessions(address);

    if (existingSessions.length >= this.MAX_SESSIONS_PER_USER) {
      // Revoke oldest session
      await this.revokeSession(existingSessions[0].id);
    }

    // Generate secure session ID
    const sessionId = crypto.randomBytes(32).toString('hex');

    // Create session with expiration
    const session = {
      id: sessionId,
      address,
      clientId,
      createdAt: Date.now(),
      expiresAt: Date.now() + this.SESSION_TIMEOUT,
      lastActivity: Date.now()
    };

    // Store encrypted session data
    await this.storeSession(session);

    return session;
  }

  async validateSession(sessionId: string): Promise<boolean> {
    const session = await this.getSession(sessionId);

    if (!session) {
      return false;
    }

    // Check expiration
    if (Date.now() > session.expiresAt) {
      await this.revokeSession(sessionId);
      return false;
    }

    // Update last activity
    await this.updateActivity(sessionId);

    return true;
  }

  private async storeSession(session: Session) {
    // Encrypt sensitive data
    const encrypted = encrypt(JSON.stringify(session));

    await db.run(
      'INSERT INTO sessions (id, data, expires_at) VALUES (?, ?, ?)',
      [session.id, encrypted, session.expiresAt]
    );
  }
}
```

## Environment Security

### Secure Environment Variables

```bash
#!/bin/bash
# secure-env.sh

# Check for required environment variables
required_vars=(
  "SESSION_SECRET"
  "JWT_ACCESS_SECRET"
  "JWT_REFRESH_SECRET"
)

for var in "${required_vars[@]}"; do
  if [ -z "${!var}" ]; then
    echo "Error: $var is not set"
    exit 1
  fi

  # Check minimum length (32 chars)
  if [ ${#!var} -lt 32 ]; then
    echo "Error: $var must be at least 32 characters"
    exit 1
  fi
done

# Check file permissions
if [ -f .env ]; then
  perms=$(stat -c %a .env)
  if [ "$perms" != "600" ]; then
    echo "Warning: .env file permissions should be 600"
    chmod 600 .env
  fi
fi
```

## Security Checklist

### Development
- [ ] Use environment variables for secrets
- [ ] Enable HTTPS in development
- [ ] Use secure random generators
- [ ] Implement input validation
- [ ] Add rate limiting
- [ ] Enable audit logging
- [ ] Test with security tools

### Production
- [ ] Generate strong secrets (min 256 bits)
- [ ] Configure TLS 1.2+ only
- [ ] Enable all security headers
- [ ] Implement comprehensive rate limiting
- [ ] Set up audit logging and monitoring
- [ ] Configure firewall rules
- [ ] Enable intrusion detection
- [ ] Regular security updates
- [ ] Backup encryption keys securely
- [ ] Document incident response plan

### Regular Audits
- [ ] Review authentication logs weekly
- [ ] Check for unusual patterns
- [ ] Monitor rate limit violations
- [ ] Review failed authentication attempts
- [ ] Check for expired sessions
- [ ] Audit database access logs
- [ ] Review code for security issues
- [ ] Update dependencies regularly
- [ ] Penetration testing quarterly
- [ ] Security training for team